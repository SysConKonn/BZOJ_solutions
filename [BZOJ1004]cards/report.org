#+TITLE: BZOJ1004

* 主要算法
  burnside定理+dp
  
* burnside定理是什么
  为了防止自己以后来看的时候不记得做法，在这里记录一下。
  （其实摘自之前集训时的归纳）
  
  Burnside引理经常用与等价类计数问题相联系，还是比较难的。
  
  其实刘汝佳的蓝书\(P144\)页已经有详细的解释了(我就是看那里才懂的)。
  
  但还是有必要总结提炼一下的。
  
  首先置换是个贯穿整个算法的东西，如果没懂置换就很难懂整个算法。
  
  其实置换并不难懂，可以简单地将其看成一个映射，可能会好懂很多。
  
  将某个东西丢进置换里去，他就变成置换里相对的一个元素了。
  
  所以引入置换的积，两个置换是可以求积的，可以将其看作函数的复合。
  
  设两个置换\(f={1,3,2}, g={2,1,3}\)，则\(fg={1,3,2}\)，怎么理解。
  
  \(fg_1\)可以先找\(f_1\),再找到\(g_f_1\),就是\(fg_1\)。
  
  所以给出几个序列就可以知道置换乘积了： 
  
  \({1->1->2 , 2->3->3 , 3->2->1}\) 
  
  \(Burnside\)如果举例就很容易理解，蓝书\(P146\)已经给出例子了。

  首先，如果不给出分类，方案数还是比较容易的。

  如果给出一种等价关系，满足等价关系的被分到一类，记为一个方案,比如“旋转\(90^{\circ}\)”

  此时应该用置换来描述这些等价关系，如果一个置换中的一个方案映射到了另一个方案，就说二者是等价的。

  所以可以定义一个置换集合\(F\)来描述它们\footnote{注意F中任意两个置换的乘积页应该在\(F\)中，否则\(F\)无法构成置换群} 

  对于一个置换\(f\)，如果一个方案\(s\)经过置换之后仍不改变，则称\(s\)为\(f\)的 *不动点*.

  将置换\(f\)的不动点记为\(C(f)\)，此时可以得出著名的\(Burnside\)引理：\[|X/G| = (\sum_{f\in G} C(f)) \div |G|\]

  其中\(|X/G|\)为不同方案数(等价类数目)，\(C(f)\)为置换\(f\)的不动点数量。

  可以浅显易懂的描述为：等价类数目为所有\(C(f)\)（不动点数目）的平均值。

  至于如何求\(C(f)\)，可以参考蓝书\(P146\) 。 
  
  一般地，如果把置换\(f\)分解成\(m(f)\)个循环的乘积，那么每个循环中的格子颜色必须相同。

  假设涂\(k\)种颜色则有 \(C(f) = k^{m(f)}\) ,带入\(Burnside\)即可得到\(Polya\)定理：\[|Y^X/G| = (\sum_{f\in G} k^{C(f)}) \div |G|

  其中，\(|Y^X/G|\)是等价类数目。其他的和上文相同。

  一般的等价类数目问题都是可以用以上两种方法做出来的。

* 那么此题如何使用这个定理做出来？
  题中已经给出：任何洗牌方式的重复叠加得到的效果肯定会与给出的某个置换效果一样。
  
  =>那么就说明，题中给出的置换已经构成了一个置换群，那么就不用考虑多次叠加的效果。 

  需要注意一点就是还有一个置换是自己不变即(1, 2, 3, 4, 5...)

  然后就是一个burnside定理的模板题了。

  我们将每个置换f()写成循环的形式。

  比如说将置换（省去上面一排） (2, 1, 3) 写成循环 => (1 2)(3)

  很显然的，同一个循环中所有颜色必须要一样。

  那我们如果要求出总方案只需要将对于每一个置换的不动点个数算出然后再求平均值即可。

  然后问题就转化成了求每一个置换对应的不动点个数。

** 如何求不动点个数
   可以使用一个背包。
   
   设f[i][j][k]为第一种颜色取i个，第二种颜色取j个，第三种颜色取k个的方案数。

   根据每个循环的大小更新f即可。

* 需要注意的
因为是平均数所以需要除以总置换个数。

然后需要求一下乘法逆元。
